#include "PBL_Helpers.ce_shader"

cbuffer ObjectData
{
	Matrix World;
	float4 ColorAndIntensity;
	float4 Radius;
};

struct PosNormColorVertex
{
	float4 Position : POSITION;
};

struct PosNormColorPixel
{
	float4 Position : SV_POSITION;
	float4 TexCoord : POSITION;
	float4 ColorAndIntensity : COLOR;
};


PosNormColorPixel VS(PosNormColorVertex aInput)
{
	PosNormColorPixel output;

	aInput.Position.w = 1.f;
	aInput.Position.xyz *= Radius.xyz;
	output.Position = mul(World, aInput.Position);
	output.Position = mul(View, output.Position);
	output.Position = mul(Projection, output.Position);

	output.ColorAndIntensity = ColorAndIntensity;

	float x = output.Position.x;
	float y = output.Position.y;
	float w = output.Position.w;

	output.TexCoord = float4((float2(x + w, w - y)) / 2, output.Position.zw);

	return output;
};


float4 PS(PosNormColorPixel anInput) : SV_TARGET
{
	anInput.TexCoord /= anInput.TexCoord.w;
	DeferredPixelData pixelData = CalculateDeferredPixelData(anInput.TexCoord.xy);

	float3 lightPosition = float3( World._14, World._24, World._34 );
	float3 toLight = lightPosition - pixelData.myWorldPosition.xyz;
	float3 lightDir = normalize(toLight);
	float3 halfVec = normalize(lightDir + pixelData.myToEye);

	float NdotL = saturate(dot(pixelData.myNormal.xyz, lightDir));
	float HdotN = saturate(dot(halfVec, pixelData.myNormal.xyz));
	float NdotV = saturate(dot(pixelData.myNormal.xyz, pixelData.myToEye));

	float3 F = saturate(Fresnel(pixelData.mySubstance.xyz, lightDir, halfVec));
	float D = saturate(D_GGX(HdotN, (pixelData.myRoughness + 1.f) / 2.f));
	float V = saturate(V_SchlickForGGX((pixelData.myRoughness + 1.f) / 2.f, NdotV, NdotL));

	float attenuation = Attenuation(toLight, Radius.x);
	float3 lightColor = ColorAndIntensity.xyz * ColorAndIntensity.w * attenuation;
	float3 directSpecc = F * D * V * NdotL * lightColor;

	return saturate(float4(directSpecc, 1.f));
};